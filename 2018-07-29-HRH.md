# Chapter 7 
## 3. package와 import

### 3.1 패키지
 패키지는 클래스의 묶음
 타 개발자의 클래스와의 충돌방지

> 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용
> 모든 클래스는 반드시 하나의 패키지에 속함
> 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있음
> 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리

### 3.2 패키지 선언
소문자로 하는것이 원칙

* 이름없는 패키지
패키지 선언하지 않은 파일들이 속하는 곳

* -d
지정된 경로를 통해 패키지의 위치를 찾아 클래스파일 생성, 디렉토리가 존재하지 않으면 디렉토리 자동생성

* 클래스 패스(class path)
패키지의 루트 디렉토리를 클래스패스에 포함시켜야지 컴파일러와 JVM이 클래스의 위치를 찾을 수 있다.

### 3.3 import문
 다른 패키지의 클래스를 사용을 간편히 하기위해서 사용(패키지명을 제외하고 사용할 수 있음)
 많이 import문을 사용해도 성능에 크게 영향 주지 않음

### 3.4 import문 선언
 import 패키지명.클래스명; 또는 import 패키지명.*;
 ctrl + shift + o 로 자동추가 가능
 주의 : import.*; 가 하위 패키지의 클래스까지 포함하는 것이 아님. 
<pre><code>
import java.util.*;
import java.text.*;

import java.*; //위 두 문장을 대신할 수 없음
 </pre></code>

------------------------------------------------------------------

## 4. 제어자
### 4.1 제어자란?
 접근 제어자와 그 외의 제어자로 나뉨
 클래스, 메서드, 멤버변수에 사용

### 4.2 static
 사용하는곳 : 멤버변수, 메서드 , 초기화 블럭
 인스턴스를 생성하지 않고 호출하여 속도가 빠름

> 멤버변수
> 모든 인스턴스에 공통적으로 사용되는 클래스변수
> 클래스변수는 인스턴스를 생성하지 않고도 사용 가능
> 클래스가 메모리에 로드될 때 생성

> 메서드
> 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드
> static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없음

<pre><code>
 class StaticTest{
 static int width = 100; //클래스 변수(static 변수)
 
 static { //클래스 초기화블럭
    //static 변수의 복잡한 초기화 수행
 }

 static int max(int a, int b){ //클래스메서드(static메서드)
     return a > b ? a : b;
 }
 }
 </pre></code>


### 4.3 final
 상수화
 사용하는곳 : 클래스, 메서드, 멤버변수, 지역변수

> 클래스
> 변경될 수 없는 클래스, 확장될 수 없는 클래스(상속불가)

> 메서드
> 변경될 수 없는 메서드(오버라이딩 불가)

> 멤버변수, 지역변수
> 값을 변경할 수 없는 상수가 됨

<pre><code>
 final class FinalTest{ //조상이될 수 없는 클래스
 final int MAX_SIZE = 10; //값을 변경할 수 없는 멤버변수(상수)

 final void getMaxSize(){ //오버라이딩할 수 없는 메서드(변경불가)
     final int LV = MAX_SIZE; //값을 변경할 수 없는 지역변수(상수)
     return MAX_SIZE;
 }
 }
 </pre></code>

 
* 생성자를 이용한 final 멤버변수 초기화
선언시에 초기화를 바로하지않고 인스턴스의 변수로 생성자에서 초기화 
<pre><code>
 class FinalTest2{ 
 final int NUMBER; //상수지만 선언과함께 초기화하지않고 생성자에서 '단 한번' 만 초기화 가능

 FinalTest2(int num){
     NUMBER = num;
 }
 }
 </pre></code>

### 4.3 abstract
 겉만 있고 알맹이는 없는 오버라이딩용

> 클래스
> 클래스 내에 추상메서드가 선언되어 있음을 의미

> 메서드
> 선언부만 작성하고 구현부는 작성하지않은 추상메서드임을 알림
<pre><code>
 abstract class AbstractTest{ //추상 클래스(추상 메서드를 포함한 클래스)
     abstract void move(); //추상 메서드(구현부가 없는 메서드)
 }
 </pre></code>

### 4.4 접근 제어자
> private : 같은 클래스 내에서만 접근 가능
> default : 같은 패키지 내에서만 접근 가능
> protected : 같은 패키지 내, 그리고 다른 패키지의 자손클래스에서 접근 가능
> public : 접근 제한 없음

* public > protected > default > private


### 4.5 캡슐화
1. 외부에서 함부로 접근하지 못하게 하기위해서
2. 외부에서 불필요한, 내부적으로만 사용되는 , 부분을 감추기 위해서
* getter and setter 을 통해 접근제어된 멤버변수에 접근가능
> 주의 : 
> 하나의 소스파일(*.java) 에는 public 클래스가 단 하나만 존재할 수 있고, 소스파일의 이름은 반드시 public 클래스의 이름과 같아야한다.

